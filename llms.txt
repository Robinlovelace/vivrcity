# vivrcity

The goal of vivrcity is to provide a simple R interface to the [Vivacity
Labs API](https://docs.vivacitylabs.com/).

## Installation

You can install the development version of vivrcity from
[GitHub](https://github.com/) with:

``` r
# install.packages("devtools")
devtools::install_github("Robinlovelace/vivrcity")
```

## Setup

You need a Vivacity API key to use this package. Save it in your
`.Renviron` file:

``` R
VIVACITY_API_KEY=your_api_key_here
```

## Usage

This example demonstrates how to retrieve metadata, counts, and
visualize traffic data.

Load the package:

``` r
library(vivrcity)
```

Development

Or for developing, clone the repo with the following command:

``` sh
gh repo clone Robinlovelace/vivrcity
```

See [GitHub CLI installation
instructions](https://github.com/cli/cli#installation) for how to
install `gh`.

And then open the folder in RStudio/VSCode/your favourite IDE and run:

``` r
devtools::load_all()
#> ℹ Loading vivrcity
```

## Countline metadata

``` r
library(dplyr)
library(ggplot2)

# Get countline metadata (returns sf object)
metadata_sf <- get_countline_metadata()
names(metadata_sf)
#>  [1] "id"                                 "name"                              
#>  [3] "sensor_name"                        "description"                       
#>  [5] "direction"                          "is_dwell_times_filtering_countline"
#>  [7] "is_anpr"                            "is_speed"                          
#>  [9] "modified_at"                        "geometry"
```

The countline dataset is represented as linestrings. For visualisation
it can be useful to convert to points:

``` r
metadata_points <- metadata_sf |>
  sf::st_centroid()
#> Warning: st_centroid assumes attributes are constant over geometries
```

You can then visualise the data with your favourite mapping package,
e.g.:

``` r
library(tmap)
tmap_mode("view")
qtm(metadata_points)
```

Note that each device typically has 2 countlines (e.g. `S38_in` and
`S38_out`):

``` r
metadata_sf$id |>
  duplicated() |>
  summary()
#>    Mode   FALSE 
#> logical     434
# for name:
metadata_sf$name |>
  duplicated() |>
  summary()
#>    Mode   FALSE    TRUE 
#> logical     430       4
# simplified name:
metadata_sf$sensor_name |>
  duplicated() |>
  summary()
#>    Mode   FALSE    TRUE 
#> logical     248     186
```

## Getting counts

``` r
# Sample 3 random countlines and rename to A, B, C
set.seed(2025)
sampled_metadata <- metadata_sf |>
  slice_sample(n = 3) |>
  mutate(sensor = c("A", "B", "C"))
sampled_ids <- sampled_metadata$id
id_lookup <- setNames(sampled_metadata$sensor, sampled_metadata$id)

# Get counts for a week in 2025
from_time <- as.POSIXct("2025-12-01", tz = "UTC")
to_time <- as.POSIXct("2025-12-17", tz = "UTC")

# Get counts by mode/class (default with get_counts)
counts <- get_counts(sampled_ids, from = from_time, to = to_time)

names(counts)
#> [1] "id"          "sensor_name" "name"        "from"        "to"         
#> [6] "direction"   "class"       "count"

# Plot pedestrians vs cyclists
counts |>
  filter(class %in% c("pedestrian", "cyclist", "car")) |>
  mutate(sensor = id_lookup[id]) |>
  group_by(sensor, class, day = as.Date(from)) |>
  summarise(count = sum(count, na.rm = TRUE), .groups = "drop") |>
  ggplot(aes(x = day, y = count, color = class)) +
  geom_line() +
  facet_wrap(~sensor, ncol = 1) +
  labs(
    x = "Date",
    y = "Count",
    color = "Mode"
  ) +
  theme_minimal()
```

![](reference/figures/README-counts-1.png)

## Getting speeds

Note: this will fail if the sensors don’t have speed recording enabled:

``` r
# Get speeds (function accepts vector of IDs)
speeds_df <- get_countline_speed(sampled_ids, from = from_time, to = to_time)
```

## Aggregating data

Sometimes you might want to aggregate data from multiple countlines that
belong to the same sensor (e.g. `S38_in` and `S38_out`). The package
provides functions to aggregate both counts and metadata.

``` r
# Aggregate counts (sums across directions for same ID)
# Note: get_counts(..., aggregate = TRUE) does this automatically
aggregated_counts <- aggregate_counts(counts)
nrow(aggregated_counts) / nrow(counts)
#> [1] 0.5
names(aggregated_counts)
#> [1] "sensor_name" "from"        "to"          "class"       "count"
```

Aggregate metadata to one row per sensor:

``` r
# Aggregate metadata (returns sf object with one row per sensor)
# Note: get_countline_metadata(aggregate = TRUE) does this automatically
metadata_aggregated <- aggregate_metadata(metadata_sf)
#> Warning: st_centroid assumes attributes are constant over geometries
names(metadata_aggregated)
#> [1] "sensor_name"  "ids"          "names"        "n_countlines" "geometry"
nrow(metadata_sf)
#> [1] 434
nrow(metadata_aggregated)
#> [1] 245
summary(aggregated_counts$sensor_name %in% metadata_aggregated$sensor_name)
#>    Mode    TRUE 
#> logical     239
```

Let’s plot the results for a single sensor:

``` r
# Filter to single sensor
single_sensor_id <- aggregated_counts$sensor_name[1]
metadata_sensor_level <- metadata_aggregated |>
  filter(sensor_name == single_sensor_id) |>
  sf::st_centroid()
metadata_count_level <- metadata_sf |>
  filter(sensor_name == single_sensor_id) 
# Verify countlines belong to same road:
metadata_count_level$name
#> [1] "S58_LeedsRd_pathLHS_wyca001" "S58_LeedsRd_road_wyca001"
plot(metadata_count_level$geometry)
plot(metadata_sensor_level$geometry, col = "red", pch = 19, add = TRUE)
```

![](reference/figures/README-single-sensor-1.png)

## Next Steps

This package currently implements a subset of the [Vivacity Traffic
Monitoring API](https://docs.vivacitylabs.com/). Future development
could include:

**Additional Countline Endpoints:** - Journey times
(`/countline/journey_times`) - requires ANPR-enabled sensors

**Zone-Based Data:** - Zonal speeds (`/zone/speeds`) - Occupancy data
(`/zone/occupancy`)  
- Turning movements (`/zone/turning_movements`) - Dwell times
(`/zone/dwell_times`)

**Other Features:** - Viewpoint metadata and data availability - Zone
metadata - Annotations support - V2 API endpoints for projects and
positions

**Improvements:** - Better error handling with informative messages -
Automatic pagination for large queries - Caching of metadata requests -
Support for all vehicle/pedestrian class types

Contributions welcome! See the [API
documentation](https://docs.vivacitylabs.com/) for endpoint details.

# Package index

## All functions

- [`aggregate_counts()`](https://robinlovelace.github.io/vivrcity/reference/aggregate_counts.md)
  : Aggregate Counts

- [`aggregate_metadata()`](https://robinlovelace.github.io/vivrcity/reference/aggregate_metadata.md)
  : Aggregate Metadata

- [`get_all_countline_counts_annual()`](https://robinlovelace.github.io/vivrcity/reference/get_all_countline_counts_annual.md)
  :

  Retrieves count data for all available countlines over a one-year
  period. This function iterates through all countlines found in
  metadata and calls
  [`get_counts()`](https://robinlovelace.github.io/vivrcity/reference/get_counts.md)
  for each, combining the results into a single data frame.

- [`get_countline_counts()`](https://robinlovelace.github.io/vivrcity/reference/get_countline_counts.md)
  : Get Countline Counts

- [`get_countline_counts_by_class()`](https://robinlovelace.github.io/vivrcity/reference/get_countline_counts_by_class.md)
  : Get Countline Counts by Class/Mode

- [`get_countline_metadata()`](https://robinlovelace.github.io/vivrcity/reference/get_countline_metadata.md)
  : Get Countline Metadata

- [`get_countline_speed()`](https://robinlovelace.github.io/vivrcity/reference/get_countline_speed.md)
  : Get Countline Speeds

- [`get_counts()`](https://robinlovelace.github.io/vivrcity/reference/get_counts.md)
  : Get Countline Counts

- [`get_hardware_metadata()`](https://robinlovelace.github.io/vivrcity/reference/get_hardware_metadata.md)
  : Get Hardware Metadata

- [`get_journey_times()`](https://robinlovelace.github.io/vivrcity/reference/get_journey_times.md)
  : Get Journey Times

- [`name_simplify()`](https://robinlovelace.github.io/vivrcity/reference/name_simplify.md)
  : Simplify Countline Name

