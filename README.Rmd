---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# vivarcity

<!-- badges: start -->
<!-- badges: end -->

The goal of vivarcity is to provide a simple R interface to the [Vivacity Labs API](https://docs.vivacitylabs.com/).

## Installation

You can install the development version of vivarcity from [GitHub](https://github.com/) with:

```r
# install.packages("devtools")
devtools::install_github("Robinlovelace/vivarcity")
```

To contribute to the package, clone it with the gh CLI:

```sh
gh repo clone Robinlovelace/vivarcity
```

And then open the folder in RStudio/VSCode/your favourite IDE and run:

```{r}
#| eval: false
devtools::load_all()
```

## Setup

You need a Vivacity API key to use this package.
Save it in your `.Renviron` file:

```
VIVACITY_API_KEY=your_api_key_here
```

## Example

This example demonstrates how to retrieve metadata, filter for relevant sensors, and visualize traffic data.

```{r example, message=FALSE, warning=FALSE}
library(vivarcity)
library(dplyr)
library(ggplot2)
library(tibble)
library(sf) # For handling spatial data

# 1. Get Countline Metadata
# This returns an sf object of all available countlines associated with the API key.
# It simplifies accessing spatial information and attributes.
metadata_sf <- get_countline_metadata()
cl_ids <- metadata_sf$id
message("Total Countlines available: ", nrow(metadata_sf))
message("Metadata structure (sf object):")
print(metadata_sf)


# 2. Sample 3 random countlines
# We will pick 3 random sensors to analyse.
set.seed(2025) 
if(nrow(metadata_sf) >= 3) {
  sampled_metadata <- metadata_sf %>% sample_n(3)
} else {
  sampled_metadata <- metadata_sf
}
sampled_ids <- sampled_metadata$id
message("\nSampled Countline IDs: ", paste(sampled_ids, collapse = ", "))


# 3. Get Counts (Last 24 hours)
# Ensure we work in UTC
to_time <- as.POSIXct(Sys.time(), tz = "UTC")
from_time <- to_time - (24 * 60 * 60) # 24 hours ago

# Convert to ISO 8601 strings required by the API
# Format: YYYY-MM-DDTHH:MM:SSZ
from_str <- format(from_time, "%Y-%m-%dT%H:%M:%SZ", tz = "UTC")
to_str <- format(to_time, "%Y-%m-%dT%H:%M:%SZ", tz = "UTC")

# Retrieve counts with robust error handling for each sampled ID
counts_data_list <- list()
for (id in sampled_ids) {
  message(paste0("Attempting to get counts for ID: ", id))
  tryCatch({
    counts_data_list[[as.character(id)]] <- get_countline_counts(id, from = from_str, to = to_str)
  }, error = function(e) {
    message(paste0("  Failed to get counts for ID ", id, ": ", e$message))
  })
}

# Filter out NULL entries if any API call failed
counts_list <- counts_data_list[!sapply(counts_data_list, is.null)]

# Process counts into a single data frame if successful
counts_df <- tibble()
if (length(counts_list) > 0) {
  counts_df <- bind_rows(lapply(names(counts_list), function(id) {
    records <- counts_list[[id]]
    bind_rows(lapply(records, function(rec) {
      cw <- if(!is.null(rec$clockwise$total)) rec$clockwise$total else 0
      acw <- if(!is.null(rec$anti_clockwise$total)) rec$anti_clockwise$total else 0
      tibble(
        id = id,
        from = as.POSIXct(rec$from, format="%Y-%m-%dT%H:%M:%S", tz="UTC"),
        count = cw + acw
      )
    }))
  }))
}

# 4. Get Speeds (Last 24 hours)
speeds_data_list <- list()
for (id in sampled_ids) {
  message(paste0("Attempting to get speeds for ID: ", id))
  tryCatch({
    speeds_data_list[[as.character(id)]] <- get_countline_speed(id, from = from_str, to = to_str)
  }, error = function(e) {
    message(paste0("  Failed to get speeds for ID ", id, ": ", e$message))
  })
}

# Filter out NULL entries if any API call failed
speeds_list <- speeds_data_list[!sapply(speeds_data_list, is.null)]

# Process speeds to get a simple summary (mean speed)
speeds_df <- tibble()
if (length(speeds_list) > 0) {
  speeds_df <- bind_rows(lapply(names(speeds_list), function(id) {
    records <- speeds_list[[id]]
    bind_rows(lapply(records, function(rec) {
      cw_mean <- if(!is.null(rec$clockwise$total$mean)) rec$clockwise$total$mean else NA
      acw_mean <- if(!is.null(rec$anti_clockwise$total$mean)) rec$anti_clockwise$total$mean else NA
      mean_speed <- mean(c(cw_mean, acw_mean), na.rm = TRUE)
      tibble(
        id = id,
        from = as.POSIXct(rec$from, format="%Y-%m-%dT%H:%M:%S", tz="UTC"),
        mean_speed = mean_speed
      )
    }))
  }))
}


# 5. Summary Statistics (Anonymized)
if (nrow(counts_df) > 0 || nrow(speeds_df) > 0) {
  counts_summary <- counts_df %>%
    group_by(id) %>%
    summarise(
      total_observations = n(),
      total_traffic_count = sum(count, na.rm = TRUE)
    )

  speeds_summary <- speeds_df %>%
    group_by(id) %>%
    summarise(
      avg_speed_kph = mean(mean_speed, na.rm = TRUE)
    )

  # Join summaries
  final_summary <- full_join(counts_summary, speeds_summary, by = "id") %>%
    mutate(id = paste("Sensor", seq_along(id))) # Anonymize IDs
  
  message("\nAnonymized Summary Statistics:")
  print(final_summary)
} else {
  message("\nNo data retrieved to generate summary statistics.")
}


# 6. Visualize Counts
# Plot traffic counts over time for the sampled sensors
if (nrow(counts_df) > 0) {
  # Anonymize IDs for plotting as well
  plot_df <- counts_df %>%
    mutate(id = as.character(match(id, sampled_ids))) %>%
    mutate(id = paste("Sensor", id))

  ggplot(plot_df, aes(x = from, y = count, color = id)) +
    geom_line() +
    labs(title = "Traffic Counts (Last 24 Hours)",
         x = "Time",
         y = "Total Vehicles",
         color = "Sensor ID") +
    theme_minimal() +
    theme(legend.position = "bottom")
} else {
  message("\nNo count data to visualize.")
}

