---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# vivrcity

<!-- badges: start -->
<!-- badges: end -->

The goal of vivrcity is to provide a simple R interface to the [Vivacity Labs API](https://docs.vivacitylabs.com/).

## Installation

You can install the development version of vivrcity from [GitHub](https://github.com/) with:

```r
# install.packages("devtools")
devtools::install_github("Robinlovelace/vivrcity")
```

## Setup

You need a Vivacity API key to use this package.
Save it in your `.Renviron` file:

```
VIVACITY_API_KEY=your_api_key_here
```

## Example

This example demonstrates how to retrieve metadata, counts, and visualize traffic data.

Load the package:

```{r, eval=FALSE}
library(vivrcity)
```

Or for developing, clone the repo with the following command:

```sh
gh repo clone Robinlovelace/vivrcity
```

See [GitHub CLI installation instructions](https://github.com/cli/cli#installation) for how to install `gh`.


And then open the folder in RStudio/VSCode/your favourite IDE and run:

```{r}
devtools::load_all()
```


```{r example, message=FALSE, warning=FALSE}
library(dplyr)
library(ggplot2)

# Get countline metadata (returns sf object)
metadata_sf <- get_countline_metadata()
names(metadata_sf)
```

The countline dataset is represented as linestrings.
For visualisation it can be useful to convert to points:

```{r}
metadata_points <- metadata_sf |>
  sf::st_centroid()
```

You can then visualise the data with your favourite mapping package, e.g.:

```{r, eval=FALSE, echo=FALSE}
library(tmap)
tmap_mode("view")
qtm(metadata_points)
```

```{r}
# Sample 3 random countlines and rename to A, B, C
set.seed(2025)
sampled_metadata <- metadata_sf |>
  slice_sample(n = 3) |>
  mutate(sensor = c("A", "B", "C"))
sampled_ids <- sampled_metadata$id
id_lookup <- setNames(sampled_metadata$sensor, sampled_metadata$id)

# Get counts for a week in 2025
from_time <- as.POSIXct("2025-12-10", tz = "UTC")
to_time <- as.POSIXct("2025-12-17", tz = "UTC")

counts_df <- get_countline_counts(sampled_ids, from = from_time, to = to_time) |>
  mutate(sensor = id_lookup[id])
```

The package automatically batches requests >7 days to work around API limits.
Here's a 365-day example:

```{r yearly}
# Get a full year of data (automatically batched into 7-day chunks)
from_year <- as.POSIXct("2025-01-01", tz = "UTC")
to_year <- as.POSIXct("2025-12-17", tz = "UTC")

yearly_counts <- get_countline_counts(sampled_ids[1], from = from_year, to = to_year)
nrow(yearly_counts)
range(yearly_counts$from)
```

Note: this will fail if the sensors don't have speed recording enabled:

```{r, eval=FALSE}
# Get speeds (function accepts vector of IDs)
speeds_df <- get_countline_speed(sampled_ids, from = from_time, to = to_time)
```

We can visualise the counts:

```{r summary}
# Summary statistics
summary_stats <- counts_df |>
  group_by(sensor) |>
  summarise(
    observations = n(),
    total_count = sum(count, na.rm = TRUE)
  )
summary_stats

# Plot traffic counts over time
ggplot(counts_df, aes(x = from, y = count, color = sensor)) +
  geom_line() +
  labs(
    title = "Traffic Counts (Dec 2025)",
    x = "Time",
    y = "Total Vehicles",
    color = "Sensor"
  ) +
  theme_minimal() +
  theme(legend.position = "bottom")
```

```{r exploratory, eval=FALSE, echo=FALSE}
# Exploring the data
highest_count <- counts_df |>
  slice_max(count)

highest_count

# Let's plot the associated sensor:
highest_count_id <- highest_count$id
highest_count_sf <- metadata_sf |>
  filter(id == highest_count_id)
library(tmap)
tmap_mode("view")
qtm(highest_count_sf)
```


## Next Steps

This package currently implements a subset of the [Vivacity Traffic Monitoring API](https://docs.vivacitylabs.com/). Future development could include:

**Additional Countline Endpoints:**
- Journey times (`/countline/journey_times`) - requires ANPR-enabled sensors

**Zone-Based Data:**
- Zonal speeds (`/zone/speeds`)
- Occupancy data (`/zone/occupancy`)  
- Turning movements (`/zone/turning_movements`)
- Dwell times (`/zone/dwell_times`)

**Other Features:**
- Viewpoint metadata and data availability
- Zone metadata
- Annotations support
- V2 API endpoints for projects and positions

**Improvements:**
- Better error handling with informative messages
- Automatic pagination for large queries
- Caching of metadata requests
- Support for all vehicle/pedestrian class types

Contributions welcome! See the [API documentation](https://docs.vivacitylabs.com/) for endpoint details.

